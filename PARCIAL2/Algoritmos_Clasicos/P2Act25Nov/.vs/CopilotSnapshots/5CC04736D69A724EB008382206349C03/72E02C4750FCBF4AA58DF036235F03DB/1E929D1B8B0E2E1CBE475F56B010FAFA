using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace P2Act25Nov
{
    internal class CColorear
    {
        private Bitmap mBitmap;
        private const int PIXEL_SIZE = 10; // Tamaño de cada píxel en la cuadrícula
        private int canvasPixelRows = 0;
        private int canvasPixelCols = 0;
        private Color targetColor; // Color objetivo a reemplazar
        private PictureBox mPictureBox; // Referencia al PictureBox

        public CColorear()
        {
            mBitmap = null;
            mPictureBox = null;
        }

        // Inicializar con el PictureBox y Bitmap
        public void Initialize(PictureBox pictureBox)
        {
            mPictureBox = pictureBox;

            // Si el PictureBox ya tiene una imagen, usarla
            if (pictureBox.Image != null)
            {
                mBitmap = new Bitmap(pictureBox.Image);
            }
            else
            {
                // Crear un nuevo bitmap del tamaño del PictureBox
                mBitmap = new Bitmap(pictureBox.Width, pictureBox.Height);
                using (Graphics g = Graphics.FromImage(mBitmap))
                {
                    g.Clear(Color.White);
                }
                pictureBox.Image = mBitmap;
            }

            canvasPixelRows = mBitmap.Height;
            canvasPixelCols = mBitmap.Width;
        }

        // Actualizar el bitmap después de dibujar figuras
        public void ActualizarBitmap()
        {
            if (mPictureBox != null && mPictureBox.Image != null)
            {
                mBitmap = new Bitmap(mPictureBox.Image);
                canvasPixelRows = mBitmap.Height;
                canvasPixelCols = mBitmap.Width;
            }
        }

        // Función FloodFill recursiva universal
        // Sigue el patrón: verifica color, pinta, y llama recursivamente en 4 direcciones
        private void MiFloodFill(int x, int y, Color color)
        {
            // Validación de límites - asegurar que estamos dentro del bitmap
            if (x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                return; // Fuera de límites
            }

            // Validar que el bitmap existe
            if (mBitmap == null)
            {
                return;
            }

            // Obtener el color del píxel actual
            Color currentColor = mBitmap.GetPixel(x, y);

            // Si el color actual es diferente al color objetivo, detener
            if (currentColor != targetColor)
            {
                return;
            }

            // Si el color actual ya es el color de reemplazo, detener (evitar recursión infinita)
            if (currentColor == color)
            {
                return;
            }

            // Pintar el píxel actual con el nuevo color
            mBitmap.SetPixel(x, y, color);

            // Llamadas recursivas en las 4 direcciones (arriba, derecha, abajo, izquierda)
            MiFloodFill(x, y + 1, color);  // Abajo
            MiFloodFill(x + 1, y, color);  // Derecha
            MiFloodFill(x, y - 1, color);  // Arriba
            MiFloodFill(x - 1, y, color);  // Izquierda
        }

        // Método para encontrar el centro de una figura cerrada
        public Point EncontrarCentroFigura()
        {
            if (mBitmap == null)
            {
                return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
            }

            // Buscar el centro del canvas como punto de inicio predeterminado
            return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
        }

        // Método para encontrar el centro de una región específica (bounding box)
        public Point EncontrarCentroRegion(Color colorBorde)
        {
            if (mBitmap == null)
            {
                return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
            }

            int minX = canvasPixelCols;
            int maxX = 0;
            int minY = canvasPixelRows;
            int maxY = 0;
            bool encontrado = false;

            // Buscar los límites de la figura
            for (int y = 0; y < canvasPixelRows; y++)
            {
                for (int x = 0; x < canvasPixelCols; x++)
                {
                    Color pixelColor = mBitmap.GetPixel(x, y);
                    
                    // Si encontramos el color del borde
                    if (pixelColor.ToArgb() == colorBorde.ToArgb())
                    {
                        encontrado = true;
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            if (encontrado)
            {
                // Calcular el centro del bounding box
                int centroX = (minX + maxX) / 2;
                int centroY = (minY + maxY) / 2;
                return new Point(centroX, centroY);
            }

            // Si no se encontró, retornar el centro del canvas
            return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
        }

        // Método público para colorear desde el centro (para usar con botón)
        public void ColorearDesdeCentro(Color nuevoColor)
        {
            Point centro = EncontrarCentroFigura();
            IniciarFloodFill(centro.X, centro.Y, nuevoColor);
        }

        // Método público para colorear desde el centro de una región específica
        public void ColorearDesdeCentroRegion(Color colorBorde, Color nuevoColor)
        {
            Point centro = EncontrarCentroRegion(colorBorde);
            IniciarFloodFill(centro.X, centro.Y, nuevoColor);
        }

        // Método público para iniciar el FloodFill desde un punto específico
        public void IniciarFloodFill(int x, int y, Color nuevoColor)
        {
            if (mBitmap == null)
            {
                MessageBox.Show("No hay bitmap inicializado", "Error");
                return;
            }

            // Validar coordenadas iniciales
            if (x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                MessageBox.Show($"Coordenadas fuera de rango:\nX: 0-{canvasPixelCols - 1}, Y: 0-{canvasPixelRows - 1}", 
                                "Error de validación");
                return;
            }

            // Guardar el color objetivo
            targetColor = mBitmap.GetPixel(x, y);

            // Si el color objetivo es igual al nuevo color, no hacer nada
            if (targetColor.ToArgb() == nuevoColor.ToArgb())
            {
                MessageBox.Show("El color seleccionado es el mismo que el área", "Información");
                return;
            }

            try
            {
                // Ejecutar el algoritmo FloodFill recursivo
                MiFloodFill(x, y, nuevoColor);

                // Actualizar la imagen del PictureBox
                if (mPictureBox != null)
                {
                    mPictureBox.Image = mBitmap;
                    mPictureBox.Refresh();
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error al colorear: {ex.Message}", "Error");
            }
        }

        // Método alternativo usando Stack (no recursivo) - más eficiente para áreas grandes
        public void FloodFillIterativo(int x, int y, Color nuevoColor)
        {
            if (mBitmap == null)
            {
                MessageBox.Show("No hay bitmap inicializado", "Error");
                return;
            }

            // Validar coordenadas iniciales
            if (x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                MessageBox.Show($"Coordenadas fuera de rango:\nX: 0-{canvasPixelCols - 1}, Y: 0-{canvasPixelRows - 1}", 
                                "Error de validación");
                return;
            }

            // Obtener el color objetivo
            Color colorObjetivo = mBitmap.GetPixel(x, y);

            // Si el color objetivo es igual al nuevo color, no hacer nada
            if (colorObjetivo.ToArgb() == nuevoColor.ToArgb())
            {
                return;
            }

            // Usar un Stack para evitar recursión (más eficiente)
            Stack<Point> pixels = new Stack<Point>();
            pixels.Push(new Point(x, y));

            while (pixels.Count > 0)
            {
                Point punto = pixels.Pop();

                // Validar límites
                if (punto.X < 0 || punto.X >= canvasPixelCols || 
                    punto.Y < 0 || punto.Y >= canvasPixelRows)
                {
                    continue;
                }

                // Verificar si el color coincide con el objetivo
                if (mBitmap.GetPixel(punto.X, punto.Y).ToArgb() == colorObjetivo.ToArgb())
                {
                    // Pintar el píxel
                    mBitmap.SetPixel(punto.X, punto.Y, nuevoColor);

                    // Agregar los 4 vecinos al stack
                    pixels.Push(new Point(punto.X, punto.Y + 1));  // Abajo
                    pixels.Push(new Point(punto.X + 1, punto.Y));  // Derecha
                    pixels.Push(new Point(punto.X, punto.Y - 1));  // Arriba
                    pixels.Push(new Point(punto.X - 1, punto.Y));  // Izquierda
                }
            }

            // Actualizar la imagen del PictureBox
            if (mPictureBox != null)
            {
                mPictureBox.Image = mBitmap;
                mPictureBox.Refresh();
            }
        }

        // Versión iterativa para colorear desde el centro
        public void ColorearDesdeCentroIterativo(Color nuevoColor)
        {
            Point centro = EncontrarCentroFigura();
            FloodFillIterativo(centro.X, centro.Y, nuevoColor);
        }

        // Obtener el color en una posición específica
        public Color ObtenerColor(int x, int y)
        {
            if (mBitmap == null || x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                return Color.Empty;
            }

            return mBitmap.GetPixel(x, y);
        }

        // Limpiar el canvas
        public void LimpiarCanvas(Color colorFondo)
        {
            if (mBitmap != null)
            {
                using (Graphics g = Graphics.FromImage(mBitmap))
                {
                    g.Clear(colorFondo);
                }

                if (mPictureBox != null)
                {
                    mPictureBox.Image = mBitmap;
                    mPictureBox.Refresh();
                }
            }
        }
    }
}

