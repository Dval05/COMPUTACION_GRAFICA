using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace P2Act25Nov
{
    internal class CCircunferencia2
    {
        private int mRadio;
        private List<Point> mLinePoints;
        private int mCurrentStep;
        private Bitmap mBitmap;
        private const int PIXEL_SIZE = 15; // Tamaño de cada píxel en la cuadrícula
        private int canvasPixelRows = 0;
        private int canvasPixelCols = 0;

        public CCircunferencia2()
        {
            mRadio = 0;
            mLinePoints = new List<Point>();
            mCurrentStep = 0;
        }

        public bool ReadData(TextBox txtRadio, PictureBox picCanvas)
        {
            bool respuesta = true;
            try
            {
                mRadio = int.Parse(txtRadio.Text);

            }
            catch
            {
                respuesta = false;
                MessageBox.Show("Ingrese Datos válidos...!", "ERROR!");
            }

            return respuesta;
        }

        public void InitializeData(TextBox txtRadio, PictureBox picCanvas)
        {
            mRadio = 0;

            txtRadio.Text = "";

            mLinePoints.Clear();
            mCurrentStep = 0;
            picCanvas.Image = null;
            picCanvas.Refresh();

            txtRadio.Focus();
        }
        public void CloseForm(Form form)
        {
            form.Close();
        }

        private bool ValidarPuntos()
        {
            if (mRadio <= 0)
            {
                MessageBox.Show("El radio debe ser un numero positivo", "Advertencia");
                return false;
            }
            return true;
        }


        public async void DrawPuntoMedio(PictureBox picCanvas)
        {
            if (!ValidarPuntos())
            {
                return;
            }

            // Calcular dimensiones en píxeles
            canvasPixelRows = picCanvas.Height / PIXEL_SIZE;
            canvasPixelCols = picCanvas.Width / PIXEL_SIZE;

            // Calcular límites con origen centrado
            int maxX = canvasPixelCols / 2;
            int minX = -maxX;
            int maxY = canvasPixelRows / 2;
            int minY = -maxY;

            if (mRadio > maxX || mRadio > maxY)
            {
                MessageBox.Show("El radio es demasiado grande para el área de dibujo", "Advertencia");
                return;
            }

            // Dibujar con animación
            await DrawCompleteAnimated(picCanvas);
        }

        private async Task DrawCompleteAnimated(PictureBox picCanvas)
        {
            InitializeCanvas(picCanvas);

            for (int i = 0; i < mLinePoints.Count; i++)
            {
                mCurrentStep = i;
                DrawUpToStep(picCanvas, i);
                await Task.Delay(10);
            }
        }

        private void InitializeCanvas(PictureBox picCanvas)
        {
            if (mBitmap == null || mBitmap.Width != picCanvas.Width || mBitmap.Height != picCanvas.Height)
                mBitmap = new Bitmap(picCanvas.Width, picCanvas.Height);

            using (Graphics g = Graphics.FromImage(mBitmap))
            {
                g.Clear(Color.White);
                DrawGrid(g, picCanvas.Width, picCanvas.Height);
            }
        }

        private void DrawPixel(int x, int y, Color color)
        {
            using (Graphics g = Graphics.FromImage(mBitmap))
            using (SolidBrush brush = new SolidBrush(color))
            {
                // Rellenar el píxel con el color
                g.FillRectangle(brush, x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);

                // Dibujar solo un borde delgado para los puntos de la circunferencia
                if (color == Color.Blue || color == Color.Red)
                {
                    using (Pen borderPen = new Pen(Color.Black, 1))
                    {
                        g.DrawRectangle(borderPen, x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE - 1, PIXEL_SIZE - 1);
                    }
                }
            }
        }

        private void DrawGrid(Graphics g, int width, int height)
        {
            using (Pen gridPen = new Pen(Color.LightGray, 1))
            using (Pen axisPen = new Pen(Color.LightGray, 2))
            {
                // Líneas verticales
                for (int x = 0; x < width; x += PIXEL_SIZE)
                {
                    g.DrawLine(gridPen, x, 0, x, height);
                }

                // Líneas horizontales
                for (int y = 0; y < height; y += PIXEL_SIZE)
                {
                    g.DrawLine(gridPen, 0, y, width, y);
                }

                // Dibujar ejes principales (X e Y) en el centro
                int centerX = width / 2;
                int centerY = height / 2;

                // Eje Y (vertical) en el centro
                g.DrawLine(axisPen, centerX, 0, centerX, height);

                // Eje X (horizontal) en el centro
                g.DrawLine(axisPen, 0, centerY, width, centerY);

                // Etiquetas de origen (0,0)
                using (Font font = new Font("Arial", 8))
                using (SolidBrush brush = new SolidBrush(Color.Black))
                {
                    g.DrawString("0", font, brush, centerX + 2, centerY + 2);
                }
            }
        }


        private void DrawUpToStep(PictureBox picCanvas, int step)
        {
            InitializeCanvas(picCanvas);

            // Centro del canvas
            int centerX = canvasPixelCols / 2;
            int centerY = canvasPixelRows / 2;

            // 1. Pintar los puntos 
            for (int i = 0; i <= Math.Min(step, mLinePoints.Count - 1); i++)
            {
                Point p = mLinePoints[i];

                int screenX = centerX + p.X;
                int screenY = centerY - p.Y;
                Color pointColor = (i == step) ? Color.Red : Color.Blue;
                DrawPixel(screenX, screenY, pointColor);
            }

            picCanvas.Image = mBitmap;
        }

        private void CalculateCircunferencePoints()
        {
            mLinePoints.Clear();
            int x = 0;
            int y = mRadio;
            int d = 1 - mRadio;
            AddCirclePoints(x, y);
            while (x < y)
            {
                if (d < 0)
                {
                    d += 2 * x + 3;
                }
                else
                {
                    d += 2 * (x - y) + 5;
                    y--;
                }
                x++;
                AddCirclePoints(x, y);
            }
        }

        private void AddCirclePoints(int x, int y)
        {
            mLinePoints.Add(new Point(x, y));
            mLinePoints.Add(new Point(y, x));
            mLinePoints.Add(new Point(-x, y));
            mLinePoints.Add(new Point(-y, x));
            mLinePoints.Add(new Point(x, -y));
            mLinePoints.Add(new Point(y, -x));
            mLinePoints.Add(new Point(-x, -y));
            mLinePoints.Add(new Point(-y, -x));
        }

        public void DrawCircunference(PictureBox picCanvas)
        {
            if (!ValidarPuntos())
            {
                return;
            }
            // Calcular los puntos de la circunferencia
            CalculateCircunferencePoints();
            // Dibujar con animación
            DrawPuntoMedio(picCanvas);
        }

        // Obtener el bitmap actual para colorear
        public Bitmap ObtenerBitmap()
        {
            return mBitmap;
        }

        // Método para colorear la circunferencia usando FloodFill ITERATIVO (no recursivo)
        public async Task ColorearCircunferencia(PictureBox picCanvas, Color color, CColorear colorear)
        {
            if (mBitmap == null)
            {
                MessageBox.Show("Primero debe dibujar una circunferencia", "Advertencia");
                return;
            }

            // Obtener el centro del canvas
            int centerX = picCanvas.Width / 2;
            int centerY = picCanvas.Height / 2;

            // Buscar un punto blanco cerca del centro
            Point puntoBlanco = BuscarPuntoBlancoCerca(centerX, centerY);

            if (puntoBlanco.X == -1)
            {
                MessageBox.Show("No se encontró un área blanca para colorear.\nIntente con un radio mayor.", "Advertencia");
                return;
            }

            // Convertir coordenadas de píxeles a coordenadas de cuadrícula
            int gridX = puntoBlanco.X / PIXEL_SIZE;
            int gridY = puntoBlanco.Y / PIXEL_SIZE;

            // Obtener el color objetivo
            int pixelCenterX = gridX * PIXEL_SIZE + PIXEL_SIZE / 2;
            int pixelCenterY = gridY * PIXEL_SIZE + PIXEL_SIZE / 2;
            Color targetColor = mBitmap.GetPixel(pixelCenterX, pixelCenterY);

            // Validar que no sea el mismo color
            if (targetColor.ToArgb() == color.ToArgb())
            {
                MessageBox.Show("El color seleccionado es el mismo que el área", "Información");
                return;
            }

            // Llamar al algoritmo ITERATIVO
            await FloodFillIterativo(gridX, gridY, color, targetColor);

            // Actualizar la imagen en el PictureBox
            picCanvas.Image = mBitmap;
            picCanvas.Refresh();
        }

        // Algoritmo FloodFill ITERATIVO usando Stack
        private async Task FloodFillIterativo(int startGridX, int startGridY, Color newColor, Color targetColor)
        {
            // Calcular las dimensiones de la cuadrícula
            int gridCols = mBitmap.Width / PIXEL_SIZE;
            int gridRows = mBitmap.Height / PIXEL_SIZE;

            // Usar una pila (Stack) para el algoritmo iterativo
            Stack<Point> pila = new Stack<Point>();
            HashSet<Point> visitados = new HashSet<Point>();

            // Agregar el punto inicial
            pila.Push(new Point(startGridX, startGridY));

            int targetArgb = targetColor.ToArgb();
            int blueArgb = Color.Blue.ToArgb();
            int redArgb = Color.Red.ToArgb();
            int blackArgb = Color.Black.ToArgb();

            // Procesar mientras haya puntos en la pila
            while (pila.Count > 0)
            {
                Point puntoActual = pila.Pop();

                // Validación de límites
                if (puntoActual.X < 0 || puntoActual.X >= gridCols ||
                    puntoActual.Y < 0 || puntoActual.Y >= gridRows)
                {
                    continue;
                }

                // Si ya fue visitado, saltar
                if (visitados.Contains(puntoActual))
                {
                    continue;
                }

                // Marcar como visitado
                visitados.Add(puntoActual);

                // Verificar el píxel central del cuadrado
                int pixelX = puntoActual.X * PIXEL_SIZE + PIXEL_SIZE / 2;
                int pixelY = puntoActual.Y * PIXEL_SIZE + PIXEL_SIZE / 2;

                if (pixelX < 0 || pixelX >= mBitmap.Width || pixelY < 0 || pixelY >= mBitmap.Height)
                {
                    continue;
                }

                Color pixelColor = mBitmap.GetPixel(pixelX, pixelY);
                int pixelArgb = pixelColor.ToArgb();

                // Si es un borde (azul, rojo o negro), detener
                if (pixelArgb == blueArgb || pixelArgb == redArgb || pixelArgb == blackArgb)
                {
                    continue;
                }

                // Si es del color objetivo, pintar
                if (pixelArgb == targetArgb)
                {
                    // Pintar el cuadrado completo
                    using (Graphics g = Graphics.FromImage(mBitmap))
                    using (SolidBrush brush = new SolidBrush(newColor))
                    {
                        g.FillRectangle(brush, puntoActual.X * PIXEL_SIZE, puntoActual.Y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                    }

                    // Actualizar la imagen para mostrar animación
                    picCanvas.Image = mBitmap;
                    picCanvas.Refresh();
                    await Task.Delay(10); // Pausa para ver la animación

                    // Agregar vecinos en orden: Oeste, Sur, Este, Norte (Stack LIFO)
                    // Se procesarán en orden: Norte, Este, Sur, Oeste
                    pila.Push(new Point(puntoActual.X - 1, puntoActual.Y));     // Oeste (izquierda)
                    pila.Push(new Point(puntoActual.X, puntoActual.Y + 1));     // Sur (abajo)
                    pila.Push(new Point(puntoActual.X + 1, puntoActual.Y));     // Este (derecha)
                    pila.Push(new Point(puntoActual.X, puntoActual.Y - 1));     // Norte (arriba)
                }
            }
        }

        // Buscar un píxel blanco cerca del punto central
        private Point BuscarPuntoBlancoCerca(int centerX, int centerY)
        {
            if (mBitmap == null)
                return new Point(-1, -1);

            Color blanco = Color.FromArgb(255, 255, 255, 255); // Blanco puro
            int whiteArgb = blanco.ToArgb();

            // Primero verificar si el centro es blanco
            if (centerX >= 0 && centerX < mBitmap.Width &&
                centerY >= 0 && centerY < mBitmap.Height)
            {
                Color centerColor = mBitmap.GetPixel(centerX, centerY);
                if (centerColor.ToArgb() == whiteArgb)
                {
                    return new Point(centerX, centerY);
                }
            }

            for (int radio = 1; radio <= 20; radio++)
            {
                // Buscar en un cuadrado alrededor del centro
                for (int dx = -radio; dx <= radio; dx++)
                {
                    for (int dy = -radio; dy <= radio; dy++)
                    {
                        int x = centerX + dx;
                        int y = centerY + dy;

                        // Validar que esté dentro del bitmap
                        if (x >= 0 && x < mBitmap.Width && y >= 0 && y < mBitmap.Height)
                        {
                            Color pixelColor = mBitmap.GetPixel(x, y);

                            // Si encontramos un píxel blanco, retornarlo
                            if (pixelColor.ToArgb() == whiteArgb)
                            {
                                return new Point(x, y);
                            }
                        }
                    }
                }
            }

            // No se encontró ningún punto blanco
            return new Point(-1, -1);
        }

        // Obtener el bitmap desde CColorear
        public Bitmap ObtenerBitmapColorear(CColorear colorear)
        {
            return colorear.ObtenerBitmap();
        }
    }
}

