using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace P2Act25Nov
{
    internal class CColorear
    {
        private Bitmap mBitmap;
        private const int PIXEL_SIZE = 10; // Tamaño de cada píxel en la cuadrícula
        private int canvasPixelRows = 0;
        private int canvasPixelCols = 0;
        private Color targetColor; // Color objetivo a reemplazar
        private PictureBox mPictureBox; // Referencia al PictureBox

        public CColorear()
        {
            mBitmap = null;
            mPictureBox = null;
        }

        // Inicializar con el PictureBox y Bitmap
        public void Initialize(PictureBox picCanvas)
        {
            mPictureBox = picCanvas;

            // Si el PictureBox ya tiene una imagen, usarla
            if (mPictureBox.Image != null)
            {
                mBitmap = new Bitmap(mPictureBox.Image);
            }
            else
            {
                // Crear un nuevo bitmap del tamaño del PictureBox
                mBitmap = new Bitmap(mPictureBox.Width, mPictureBox.Height);
                using (Graphics g = Graphics.FromImage(mBitmap))
                {
                    g.Clear(Color.White);
                }
                mPictureBox.Image = mBitmap;
            }

            canvasPixelRows = mBitmap.Height;
            canvasPixelCols = mBitmap.Width;
        }

        // Actualizar el bitmap después de dibujar figuras
        public void ActualizarBitmap()
        {
            if (mPictureBox != null && mPictureBox.Image != null)
            {
                mBitmap = new Bitmap(mPictureBox.Image);
                canvasPixelRows = mBitmap.Height;
                canvasPixelCols = mBitmap.Width;
            }
        }

        private int pixelsPainted = 0; // Contador de píxeles pintados

        private async Task MiFloodFillAsync(int x, int y, Color color)
        {
            // Usar una pila (Stack) en lugar de recursión para evitar StackOverflowException
            Stack<Point> pila = new Stack<Point>();
            HashSet<Point> visitados = new HashSet<Point>();
            
            // Agregar el punto inicial
            pila.Push(new Point(x, y));
            
            // Colores que son BORDES y NO se deben cruzar
            int blackArgb = Color.Black.ToArgb();
            int blueArgb = Color.Blue.ToArgb();
            int redArgb = Color.Red.ToArgb();
            int lightGrayArgb = Color.LightGray.ToArgb();
            int targetArgb = targetColor.ToArgb();
            
            // Procesar mientras haya puntos en la pila
            while (pila.Count > 0)
            {
                Point puntoActual = pila.Pop();
                
                // Validación de límites
                if (puntoActual.X < 0 || puntoActual.X >= canvasPixelCols || 
                    puntoActual.Y < 0 || puntoActual.Y >= canvasPixelRows)
                {
                    continue;
                }
                
                // Si ya fue visitado, saltar
                if (visitados.Contains(puntoActual))
                {
                    continue;
                }
                
                // Marcar como visitado
                visitados.Add(puntoActual);
                
                // Obtener el color del píxel actual
                int currentArgb = mBitmap.GetPixel(puntoActual.X, puntoActual.Y).ToArgb();
                
                // Si es un borde de la circunferencia, detener
                if (currentArgb == blackArgb || currentArgb == blueArgb || currentArgb == redArgb)
                {
                    continue;
                }
                
                // Verificar si el píxel actual es del color objetivo O es una línea de cuadrícula
                if (currentArgb == targetArgb || currentArgb == lightGrayArgb)
                {
                    // Solo pintar si NO es una línea gris (las líneas grises solo se saltan)
                    if (currentArgb != lightGrayArgb)
                    {
                        mBitmap.SetPixel(puntoActual.X, puntoActual.Y, color);
                        pixelsPainted++;
                        
                        // Actualizar la imagen en el PictureBox para mostrar animación
                        if (mPictureBox != null)
                        {
                            mPictureBox.Image = mBitmap;
                            mPictureBox.Refresh();
                            await Task.Delay(10); // Pausa para ver la animación (10ms por píxel)
                        }
                    }
                    
                    // Agregar vecinos a la pila en el orden: Oeste, Sur, Este, Norte
                    // (Orden inverso porque Stack es LIFO - Last In First Out)
                    pila.Push(new Point(puntoActual.X - 1, puntoActual.Y));  // Oeste (izquierda)
                    pila.Push(new Point(puntoActual.X, puntoActual.Y + 1));  // Sur (abajo)
                    pila.Push(new Point(puntoActual.X + 1, puntoActual.Y));  // Este (derecha)
                    pila.Push(new Point(puntoActual.X, puntoActual.Y - 1));  // Norte (arriba)
                }
            }
        }

        // Método para encontrar el centro de una figura cerrada
        public Point EncontrarCentroFigura()
        {
            if (mBitmap == null)
            {
                return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
            }

            // Buscar el centro del canvas como punto de inicio predeterminado
            return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
        }

        // Método para encontrar el centro de una región específica (bounding box)
        public Point EncontrarCentroRegion(Color colorBorde)
        {
            if (mBitmap == null)
            {
                return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
            }

            int minX = canvasPixelCols;
            int maxX = 0;
            int minY = canvasPixelRows;
            int maxY = 0;
            bool encontrado = false;

            // Buscar los límites de la figura
            for (int y = 0; y < canvasPixelRows; y++)
            {
                for (int x = 0; x < canvasPixelCols; x++)
                {
                    Color pixelColor = mBitmap.GetPixel(x, y);
                    
                    // Si encontramos el color del borde
                    if (pixelColor.ToArgb() == colorBorde.ToArgb())
                    {
                        encontrado = true;
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            if (encontrado)
            {
                // Calcular el centro del bounding box
                int centroX = (minX + maxX) / 2;
                int centroY = (minY + maxY) / 2;
                return new Point(centroX, centroY);
            }

            // Si no se encontró, retornar el centro del canvas
            return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
        }

        // Método público para colorear desde el centro (para usar con botón)
        public async Task ColorearDesdeCentro(Color nuevoColor)
        {
            Point centro = EncontrarCentroFigura();
            await IniciarFloodFill(centro.X, centro.Y, nuevoColor);
        }

        // Método público para colorear desde el centro de una región específica
        public async Task ColorearDesdeCentroRegion(Color colorBorde, Color nuevoColor)
        {
            Point centro = EncontrarCentroRegion(colorBorde);
            await IniciarFloodFill(centro.X, centro.Y, nuevoColor);
        }

        public async Task IniciarFloodFill(int x, int y, Color nuevoColor)
        {
            if (mBitmap == null)
            {
                MessageBox.Show("No hay bitmap inicializado", "Error");
                return;
            }

            // Validar coordenadas iniciales
            if (x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                MessageBox.Show($"Coordenadas fuera de rango:\nX: 0-{canvasPixelCols - 1}, Y: 0-{canvasPixelRows - 1}", 
                                "Error de validación");
                return;
            }

            // Guardar el color objetivo
            targetColor = mBitmap.GetPixel(x, y);

            // Información de debug
            string debugInfo = $"Punto inicial: ({x}, {y})\n" +
                              $"Color objetivo: R={targetColor.R}, G={targetColor.G}, B={targetColor.B}, A={targetColor.A}\n" +
                              $"Color nuevo: R={nuevoColor.R}, G={nuevoColor.G}, B={nuevoColor.B}, A={nuevoColor.A}\n" +
                              $"Canvas: {canvasPixelCols} x {canvasPixelRows}";
            
            MessageBox.Show(debugInfo, "DEBUG - Información de inicio");

            // Si el color objetivo es igual al nuevo color, no hacer nada
            if (targetColor.ToArgb() == nuevoColor.ToArgb())
            {
                MessageBox.Show("El color seleccionado es el mismo que el área", "Información");
                return;
            }

            try
            {
                // Reiniciar contador
                pixelsPainted = 0;
                
                // Llamar al algoritmo iterativo con animación
                await MiFloodFillAsync(x, y, nuevoColor);

                // Actualizar la imagen del PictureBox (final)
                if (mPictureBox != null)
                {
                    mPictureBox.Image = mBitmap;
                    mPictureBox.Refresh();
                }
                
                MessageBox.Show($"Coloreo completado\nPíxeles pintados: {pixelsPainted}", "DEBUG - Fin");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error al colorear: {ex.Message}\nStack: {ex.StackTrace}", "Error");
            }
        }

        // Obtener el color en una posición específica
        public Color ObtenerColor(int x, int y)
        {
            if (mBitmap == null || x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                return Color.Empty;
            }

            return mBitmap.GetPixel(x, y);
        }

        // Limpiar el canvas
        public void LimpiarCanvas(Color colorFondo)
        {
            if (mBitmap != null)
            {
                using (Graphics g = Graphics.FromImage(mBitmap))
                {
                    g.Clear(colorFondo);
                }

                if (mPictureBox != null)
                {
                    mPictureBox.Image = mBitmap;
                    mPictureBox.Refresh();
                }
            }
        }

        // Obtener el bitmap actual
        public Bitmap ObtenerBitmap()
        {
            return mBitmap;
        }
    }
}

