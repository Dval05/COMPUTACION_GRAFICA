using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace P2Act25Nov
{
    internal class CColorear
    {
        private Bitmap mBitmap;
        private const int PIXEL_SIZE = 10; // Tamaño de cada píxel en la cuadrícula
        private int canvasPixelRows = 0;
        private int canvasPixelCols = 0;
        private Color targetColor; // Color objetivo a reemplazar
        private PictureBox mPictureBox; // Referencia al PictureBox

        public CColorear()
        {
            mBitmap = null;
            mPictureBox = null;
        }

        // Inicializar con el PictureBox y Bitmap
        public void Initialize(PictureBox pictureBox)
        {
            mPictureBox = pictureBox;

            // Si el PictureBox ya tiene una imagen, usarla
            if (pictureBox.Image != null)
            {
                mBitmap = new Bitmap(pictureBox.Image);
            }
            else
            {
                // Crear un nuevo bitmap del tamaño del PictureBox
                mBitmap = new Bitmap(pictureBox.Width, pictureBox.Height);
                using (Graphics g = Graphics.FromImage(mBitmap))
                {
                    g.Clear(Color.White);
                }
                pictureBox.Image = mBitmap;
            }

            canvasPixelRows = mBitmap.Height;
            canvasPixelCols = mBitmap.Width;
        }

        // Actualizar el bitmap después de dibujar figuras
        public void ActualizarBitmap()
        {
            if (mPictureBox != null && mPictureBox.Image != null)
            {
                mBitmap = new Bitmap(mPictureBox.Image);
                canvasPixelRows = mBitmap.Height;
                canvasPixelCols = mBitmap.Width;
            }
        }

        private int pixelsPainted = 0; // Contador de píxeles pintados

        private void MiFloodFill(int x, int y, Color color)
        {
            // Validación de límites
            if (x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                return;
            }

            // Obtener el color del píxel actual
            Color currentColor = mBitmap.GetPixel(x, y);
            
            // Verificar si el píxel actual es del color objetivo
            if (currentColor.ToArgb() == targetColor.ToArgb())
            {
                // Pintar el píxel con el nuevo color
                mBitmap.SetPixel(x, y, color);
                pixelsPainted++;

                // Llamadas recursivas en las 4 direcciones (Norte, Este, Sur, Oeste)
                MiFloodFill(x, y + 1, color);  // Sur (abajo)
                MiFloodFill(x + 1, y, color);  // Este (derecha)
                MiFloodFill(x, y - 1, color);  // Norte (arriba)
                MiFloodFill(x - 1, y, color);  // Oeste (izquierda)
            }
        }

        // Método para encontrar el centro de una figura cerrada
        public Point EncontrarCentroFigura()
        {
            if (mBitmap == null)
            {
                return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
            }

            // Buscar el centro del canvas como punto de inicio predeterminado
            return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
        }

        // Método para encontrar el centro de una región específica (bounding box)
        public Point EncontrarCentroRegion(Color colorBorde)
        {
            if (mBitmap == null)
            {
                return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
            }

            int minX = canvasPixelCols;
            int maxX = 0;
            int minY = canvasPixelRows;
            int maxY = 0;
            bool encontrado = false;

            // Buscar los límites de la figura
            for (int y = 0; y < canvasPixelRows; y++)
            {
                for (int x = 0; x < canvasPixelCols; x++)
                {
                    Color pixelColor = mBitmap.GetPixel(x, y);
                    
                    // Si encontramos el color del borde
                    if (pixelColor.ToArgb() == colorBorde.ToArgb())
                    {
                        encontrado = true;
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            if (encontrado)
            {
                // Calcular el centro del bounding box
                int centroX = (minX + maxX) / 2;
                int centroY = (minY + maxY) / 2;
                return new Point(centroX, centroY);
            }

            // Si no se encontró, retornar el centro del canvas
            return new Point(canvasPixelCols / 2, canvasPixelRows / 2);
        }

        // Método público para colorear desde el centro (para usar con botón)
        public void ColorearDesdeCentro(Color nuevoColor)
        {
            Point centro = EncontrarCentroFigura();
            IniciarFloodFill(centro.X, centro.Y, nuevoColor);
        }

        // Método público para colorear desde el centro de una región específica
        public void ColorearDesdeCentroRegion(Color colorBorde, Color nuevoColor)
        {
            Point centro = EncontrarCentroRegion(colorBorde);
            IniciarFloodFill(centro.X, centro.Y, nuevoColor);
        }

        public void IniciarFloodFill(int x, int y, Color nuevoColor)
        {
            if (mBitmap == null)
            {
                MessageBox.Show("No hay bitmap inicializado", "Error");
                return;
            }

            // Validar coordenadas iniciales
            if (x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                MessageBox.Show($"Coordenadas fuera de rango:\nX: 0-{canvasPixelCols - 1}, Y: 0-{canvasPixelRows - 1}", 
                                "Error de validación");
                return;
            }

            // Guardar el color objetivo
            targetColor = mBitmap.GetPixel(x, y);

            // Información de debug
            string debugInfo = $"Punto inicial: ({x}, {y})\n" +
                              $"Color objetivo: R={targetColor.R}, G={targetColor.G}, B={targetColor.B}, A={targetColor.A}\n" +
                              $"Color nuevo: R={nuevoColor.R}, G={nuevoColor.G}, B={nuevoColor.B}, A={nuevoColor.A}\n" +
                              $"Canvas: {canvasPixelCols} x {canvasPixelRows}";
            
            MessageBox.Show(debugInfo, "DEBUG - Información de inicio");

            // Si el color objetivo es igual al nuevo color, no hacer nada
            if (targetColor.ToArgb() == nuevoColor.ToArgb())
            {
                MessageBox.Show("El color seleccionado es el mismo que el área", "Información");
                return;
            }

            try
            {
                // Reiniciar contador
                pixelsPainted = 0;
                
                // Llamar al algoritmo recursivo
                MiFloodFill(x, y, nuevoColor);

                // Actualizar la imagen del PictureBox
                if (mPictureBox != null)
                {
                    mPictureBox.Image = mBitmap;
                    mPictureBox.Refresh();
                }
                
                MessageBox.Show($"Coloreo completado\nPíxeles pintados: {pixelsPainted}", "DEBUG - Fin");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error al colorear: {ex.Message}\nStack: {ex.StackTrace}", "Error");
            }
        }

        // Obtener el color en una posición específica
        public Color ObtenerColor(int x, int y)
        {
            if (mBitmap == null || x < 0 || x >= canvasPixelCols || y < 0 || y >= canvasPixelRows)
            {
                return Color.Empty;
            }

            return mBitmap.GetPixel(x, y);
        }

        // Limpiar el canvas
        public void LimpiarCanvas(Color colorFondo)
        {
            if (mBitmap != null)
            {
                using (Graphics g = Graphics.FromImage(mBitmap))
                {
                    g.Clear(colorFondo);
                }

                if (mPictureBox != null)
                {
                    mPictureBox.Image = mBitmap;
                    mPictureBox.Refresh();
                }
            }
        }

        // Obtener el bitmap actual
        public Bitmap ObtenerBitmap()
        {
            return mBitmap;
        }
    }
}

